package com.penruins.main.thread.producer_consumer;


/**
 * 在并发编程中使用生产者和消费者模式能够解决绝大部分并发问题。
 * 该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度
 *
 * 在线程世界中，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，
 * 如果生产者处理肃立很快，而消费者处理速度很慢，
 * 那么生产者就必须等待消费者处理完，才能继续生产数据。
 * 同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。
 *
 * 生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。
 * 生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，
 * 所以生产者生产完数据后不用等待消费者处理，直接扔给阻塞队列，
 * 消费者不找生产者要数据，而是直接从阻塞队列里取
 * 阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力
 *
 */
public class Main {
    /**
     * 生产者是一堆线程，消费者是另一堆线程，内存缓冲区可以使用List数组队列
     * 数据类型只需要定义一个简单的类就好。
     * 关键是如何处理多线程之间的协作。
     *
     * 在这个模型中，最关键就是缓冲区为空的时候消费者必须等待，而内存缓冲区满的时候
     * 生产者必须等待。其他时候可以是个动态平衡。
     * 值得注意的是多线程对临界区资源的操作时候必须保证在读写中智能存在一个线程
     * 所有需要设计锁的策略
     */


    /**
     * 生产者负责生产一个数字；吧存入缓冲区，消费者从缓冲区中取出数据并且求出它的平方
     * 并输出
     */
}
