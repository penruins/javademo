package com.penruins.algorithm;


/**
 * 贪心算法 Greedy Algorith
 * 是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说
 * 不从整体最优解出发来考虑，它所做出的仅是在某种意义上的局部最优解
 *
 * 贪婪算法是一种分阶段的工作，在每一个阶段，可以认为所做决定是最好的，
 * 而不考虑将来的后果
 *
 * 贪心策略适用的前提是：局部最优解能导致产生全局最优解
 * 也就是当算法终止的时候，局部最优等于全局最优
 */
public class GreedyAlgorithm {

    /**
     * 纸币找零问题
     * 问题：假设1元、2元、5元、10元、20元，50元、100元，张数不限制，现在要用来支付K元
     * 至少要多少张纸币？
     *
     * 很显然，我们很容易就想到使用贪心算法来解决，并且我们所根据的贪心策略是
     * 每一步尽可能用面值大的纸币即可。当然这是正确的
     *
     *
     * 代码的正确性有待进一步思考
     *
     * @param money
     */
    static void greedyGiveMoney(int money) {
        System.out.println("需要找零：" + money);
        int[] moneyLevel = {1,5,10,20,50,100};
        for(int i=moneyLevel.length-1;i>=0;i--) {
            int num = money / moneyLevel[i];
            int mod = money % moneyLevel[i];
            money = mod;
            if(num > 0) {
                System.out.println("需要" + num + "张" + moneyLevel[0] + "块的");
            }
        }
    }

    /**
     * 用动态规划的思想尝试思考
     *
     * 什么是动态规划思想？
     *      将求解问题分解成若干个子问题，先求解子问题，并将这些子问题的解保存起来，如果以后在求解
     *      较大子问题的时候需要用到这些子问题的解，就可以直接取出这些已经计算过的解而免去了重复计算
     *
     *
     *  问题描述：假设一堆面值为1，2，5，21，25元，需要找出总值T为63元的零钱
     *          最少需要多个个硬币才能找出
     *
     *  基于动态规划的思想，我们可以从1元开始计算出最少需要几个硬币，然后再求2元、3元...
     *  每一次求得的结果都保存在一个数组中，以后需要用到时则直接取出即可
     *
     *
     *  我们在从1元开始以此找零时，我们尝试一下当前要找零的面值是否能够被分解成另一个已求解的面值的
     *  找零需要的硬币个数再加上这一堆硬币中的某个面值之和，如果这样分解之后最终的硬币数是最少的
     *  那么问题就得到答案了
     *
     *  values[] 保存每一种硬币的币值的数组
     *  valueKinds 币值不同的硬币种类数量，即values[]数组的大小
     *  money 需要找零的面值
     *  coinsUsed[] 保存面值为i的纸币找零所需的最小硬币数
     *
     *
     *  当求解总面值为i的找零最少硬币数coinsUsed[i]时，将其分解成求解coinsUsed[i-cents]和一个面值
     *  为cents元的硬币，由于i-cents<i，其解coinsUsed[i-cents]已经存在，如果面值为cents的硬币满足
     *  题意，那么最终解coinsUsed[i]则等于coinsUsed[i-cents]再加上1的这一个硬币
     */

}






















